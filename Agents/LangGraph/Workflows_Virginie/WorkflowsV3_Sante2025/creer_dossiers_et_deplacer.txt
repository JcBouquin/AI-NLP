def creer_dossiers_et_deplacer(analyses: list) -> dict:
    """
    Phase 4: CrÃ©e les dossiers de classification et dÃ©place les fichiers.

    Args:
        analyses: Une liste de dictionnaires d'analyse pour chaque fichier.
    """
    print(f"\nğŸ“ PHASE 4: CrÃ©ation dossiers et dÃ©placement...")
    print("-" * 50)
    
    # Mapping des catÃ©gories vers les noms de dossiers
    mapping_dossiers = {
        'oncologie': 'ONCOLOGIE',
        'cardiologie': 'CARDIOLOGIE',
        'neurologie': 'NEUROLOGIE',
        'diabetologie': 'DIABETOLOGIE',
        'pneumologie': 'PNEUMOLOGIE',
        'dermatologie': 'DERMATOLOGIE',
        'pharmacovigilance': 'PHARMACOVIGILANCE',
        'formation': 'FORMATION',
        'commercial': 'COMMERCIAL',
        'recherche': 'RECHERCHE',
        'reglementaire': 'REGLEMENTAIRE',
        'client': 'CLIENTS',
        'base_donnees': 'BASES_DONNEES',
        'autre': 'AUTRES',
        'aucun': 'AUTRES',
        'null': 'AUTRES',
        'inconnu': 'AUTRES',
        'autres': 'AUTRES'
    }
    
    # CrÃ©er tous les dossiers nÃ©cessaires en utilisant les valeurs du mapping
    dossiers_crees = set()
    for categorie in mapping_dossiers.values():
        dossier_path = os.path.join(CHEMIN_DEPOTS, categorie)
        os.makedirs(dossier_path, exist_ok=True)
        dossiers_crees.add(categorie)
    
    print(f"âœ… {len(dossiers_crees)} dossiers de classification crÃ©Ã©s.")

    # Logique pour dÃ©terminer le dossier cible Ã  partir de l'analyse LLM
    def get_dossier_cible(analyse: dict) -> str:
        """DÃ©termine le dossier cible en fonction des rÃ©sultats de l'analyse."""
        # 1. PrioritÃ© aux bases de donnÃ©es
        if analyse.get('base_principale') and analyse.get('base_principale') != 'null':
            return mapping_dossiers.get('base_donnees', 'AUTRES')
        
        # 2. PrioritÃ© aux clients
        if analyse.get('client_principal') and analyse.get('client_principal') != 'null':
            return mapping_dossiers.get('client', 'AUTRES')
        
        # 3. PrioritÃ© aux domaines mÃ©dicaux
        domaine_medical = analyse.get('domaine_medical')
        if domaine_medical and domaine_medical not in ['business', 'client', 'base_donnees', 'aucun', 'null']:
            return mapping_dossiers.get(domaine_medical, 'AUTRES')
        
        # 4. PrioritÃ© aux contextes principaux
        contexte_principal = analyse.get('contexte_principal')
        if contexte_principal and contexte_principal not in ['client', 'base_donnees', 'autre', 'null']:
            return mapping_dossiers.get(contexte_principal, 'AUTRES')
        
        # 5. Repli par dÃ©faut
        return mapping_dossiers.get('autres', 'AUTRES')
    
    # DÃ©placer les fichiers
    stats_deplacement = {}
    erreurs_deplacement = []
    
    for analyse in analyses:
        file_name = analyse['nom_fichier']
        
        # â­ï¸ Ligne modifiÃ©e pour utiliser la nouvelle logique de classification
        dossier_cible = get_dossier_cible(analyse)
        
        source_path = os.path.join(CHEMIN_DEPOTS, file_name)
        destination_path = os.path.join(CHEMIN_DEPOTS, dossier_cible, file_name)
        
        try:
            if os.path.exists(source_path):
                # GÃ©rer les doublons
                if os.path.exists(destination_path):
                    base, ext = os.path.splitext(file_name)
                    counter = 1
                    while os.path.exists(destination_path):
                        new_name = f"{base}_({counter}){ext}"
                        destination_path = os.path.join(CHEMIN_DEPOTS, dossier_cible, new_name)
                        counter += 1
                
                shutil.move(source_path, destination_path)
                stats_deplacement[dossier_cible] = stats_deplacement.get(dossier_cible, 0) + 1
        
        except Exception as e:
            erreurs_deplacement.append(f"{file_name}: {str(e)}")
            print(f"âŒ Erreur dÃ©placement {file_name}: {e}")
    
    print(f"\nğŸ“Š RÃ‰SULTATS DE DÃ‰PLACEMENT:")
    total_deplaces = sum(stats_deplacement.values())
    for dossier, count in sorted(stats_deplacement.items()):
        pct = (count / total_deplaces * 100) if total_deplaces > 0 else 0
        print(f"   â€¢ {dossier}: {count} fichiers ({pct:.1f}%)")
    
    if erreurs_deplacement:
        print(f"\nâŒ ERREURS DE DÃ‰PLACEMENT ({len(erreurs_deplacement)}):")
        for erreur in erreurs_deplacement[:5]:
            print(f"   â€¢ {erreur}")
        if len(erreurs_deplacement) > 5:
            print(f"   â€¢ ... et {len(erreurs_deplacement) - 5} autres erreurs")
    
    return stats_deplacement