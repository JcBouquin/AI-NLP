# üéØ ABSOLUMENT ! C'est une id√©e EXCELLENTE et tr√®s coh√©rente avec Parlant !

Vous venez de comprendre le **pattern fondamental** de Parlant : cr√©er des **outils sp√©cialis√©s** pour diff√©rents types de donn√©es/comportements.

## ‚úÖ Pourquoi c'est parfaitement coh√©rent

### Pattern Parlant : **1 Source de Donn√©es = 1 Tool Sp√©cialis√©**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ AGENT PARLANT (Chef d'orchestre)                        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                          ‚îÇ
‚îÇ  Guideline 1: "Questions sur politiques cabinet"        ‚îÇ
‚îÇ  ‚Üí Tool: qna (FAQ statiques)                           ‚îÇ
‚îÇ                                                          ‚îÇ
‚îÇ  Guideline 2: "Questions sur donn√©es patients"          ‚îÇ
‚îÇ  ‚Üí Tool: sql-agent (Base de donn√©es priv√©e)            ‚îÇ
‚îÇ                                                          ‚îÇ
‚îÇ  Guideline 3: "Questions sur rendez-vous disponibles"   ‚îÇ
‚îÇ  ‚Üí Tool: calendar-api (API externe)                    ‚îÇ
‚îÇ                                                          ‚îÇ
‚îÇ  Guideline 4: "Calculs m√©dicaux"                       ‚îÇ
‚îÇ  ‚Üí Tool: medical-calculator                            ‚îÇ
‚îÇ                                                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## üèóÔ∏è Architecture de votre `parlant-sql` (inspir√© de `parlant-qna`)

### Structure propos√©e :

```
parlant-sql/
‚îú‚îÄ‚îÄ parlant_sql/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ app.py              # Logique principale (comme qna/app.py)
‚îÇ   ‚îú‚îÄ‚îÄ module.py           # Module pour Parlant
‚îÇ   ‚îî‚îÄ‚îÄ cli.py              # Interface CLI
‚îÇ
‚îú‚îÄ‚îÄ database_schema/        # Comme medical_faq/
‚îÇ   ‚îú‚îÄ‚îÄ patients_table.md
‚îÇ   ‚îú‚îÄ‚îÄ appointments_table.md
‚îÇ   ‚îú‚îÄ‚îÄ doctors_table.md
‚îÇ   ‚îú‚îÄ‚îÄ prescriptions_table.md
‚îÇ   ‚îî‚îÄ‚îÄ SCHEMA_DESCRIPTION.md
‚îÇ
‚îú‚îÄ‚îÄ text_to_sql_examples/   # Exemples d'apprentissage
‚îÇ   ‚îú‚îÄ‚îÄ count_queries.md
‚îÇ   ‚îú‚îÄ‚îÄ join_queries.md
‚îÇ   ‚îú‚îÄ‚îÄ date_filters.md
‚îÇ   ‚îî‚îÄ‚îÄ aggregations.md
‚îÇ
‚îî‚îÄ‚îÄ load_schema.bat         # Comme load_medical_faq.bat
```

## üìÑ Exemple de Fichier .md pour une Table

### `database_schema/patients_table.md`

```markdown
# Combien de patients avons-nous ?
# Quel est le nombre total de patients ?
# Liste tous les patients

**Table:** patients

**Colonnes:**
- id (INTEGER PRIMARY KEY)
- first_name (TEXT)
- last_name (TEXT)
- date_of_birth (DATE)
- email (TEXT)
- phone (TEXT)
- created_at (TIMESTAMP)

**Exemples de requ√™tes:**

```sql
-- Compter tous les patients
SELECT COUNT(*) FROM patients;

-- Lister les patients r√©cents
SELECT first_name, last_name, email 
FROM patients 
WHERE created_at > DATE('now', '-30 days');

-- Chercher un patient par nom
SELECT * FROM patients 
WHERE last_name LIKE '%Martin%';
```

**R√®gles de s√©curit√©:**
- Jamais exposer les donn√©es sensibles (num√©ro s√©cu, mot de passe)
- Toujours limiter les r√©sultats (LIMIT 100)
- Pas de DELETE ou UPDATE autoris√©
```

## üíª Exemple de `parlant_sql/app.py` (inspir√© de QNA)

```python
# parlant_sql/app.py

import asyncio
from dataclasses import dataclass
from typing import Optional, Literal
import sqlite3

from parlant.core.common import DefaultBaseModel
from parlant.core.nlp.service import NLPService

# Sch√©ma pour la g√©n√©ration structur√©e
class _SQLQuerySchema(DefaultBaseModel):
    user_question: str
    question_analysis: str  # Analyser ce que demande l'user
    
    # Tables pertinentes identifi√©es
    relevant_tables: list[str]
    relevant_columns: dict[str, list[str]]  # table -> colonnes
    
    # Raisonnement
    query_strategy: str  # Comment construire la requ√™te
    potential_joins: list[str]  # Jointures n√©cessaires
    filters_needed: list[str]  # Filtres WHERE
    
    # G√©n√©ration SQL
    sql_query_draft: str
    security_check: str  # V√©rifier qu'il n'y a pas de DROP/DELETE
    sql_query_final: str
    
    # Explication
    query_explanation: str  # Expliquer la requ√™te en fran√ßais
    expected_result_format: str
    
    # M√©tadonn√©es
    confidence: Literal["high", "medium", "low"]
    requires_human_approval: bool  # Si requ√™te complexe/risqu√©e

@dataclass
class SQLResult:
    query: str
    data: list[dict]
    explanation: str
    confidence: str
    approved: bool


class SQLAgent:
    def __init__(
        self,
        db_path: str,
        service: NLPService,
        logger,
    ):
        self._db_path = db_path
        self._service = service
        self.logger = logger
        self._schema_info: dict[str, str] = {}
        
    async def __aenter__(self):
        # Charger les sch√©mas depuis database_schema/
        self._generator = await self._service.get_schematic_generator(
            _SQLQuerySchema
        )
        return self
        
    async def query_database(
        self, 
        natural_language_question: str
    ) -> SQLResult:
        """Convertir question naturelle ‚Üí SQL ‚Üí R√©sultats"""
        
        # Formater les infos de sch√©ma
        schema_context = self._format_schema_context()
        
        prompt = f"""
You are an expert SQL agent for a medical database.

Your job is to:
1. Analyze the user's natural language question
2. Identify which tables and columns are relevant
3. Generate a SAFE SQL query (SELECT only, no DELETE/UPDATE/DROP)
4. Explain the query in simple terms

IMPORTANT SECURITY RULES:
- ONLY SELECT queries are allowed
- Always use LIMIT 100 to prevent overwhelming results
- Never expose sensitive data (passwords, social security numbers)
- Use parameterized queries to prevent SQL injection

Database Schema: ###
{schema_context}
###

Few-Shot Examples: ###
Question: "Combien de rendez-vous avons-nous aujourd'hui ?"
SQL: SELECT COUNT(*) FROM appointments WHERE date = DATE('now');

Question: "Liste les patients du Dr. Martin"
SQL: SELECT p.first_name, p.last_name, p.phone 
     FROM patients p 
     JOIN appointments a ON p.id = a.patient_id 
     JOIN doctors d ON a.doctor_id = d.id 
     WHERE d.last_name = 'Martin' 
     LIMIT 100;
###

User Question: ###
{natural_language_question}
###

Generate a JSON response with your complete analysis and SQL query.
"""

        # G√©n√©rer la requ√™te structur√©e
        result = await self._generator.generate(
            prompt,
            hints={"strict": True, "temperature": 0.1}
        )
        
        self.logger.debug(result.content.model_dump_json(indent=2))
        
        # V√©rifications de s√©curit√©
        sql = result.content.sql_query_final.upper()
        dangerous_keywords = ["DELETE", "DROP", "UPDATE", "INSERT", "ALTER"]
        
        if any(kw in sql for kw in dangerous_keywords):
            self.logger.warning("Dangerous SQL blocked!")
            return SQLResult(
                query="",
                data=[],
                explanation="Requ√™te refus√©e pour raisons de s√©curit√©",
                confidence="low",
                approved=False
            )
        
        # Ex√©cuter la requ√™te
        try:
            conn = sqlite3.connect(self._db_path)
            conn.row_factory = sqlite3.Row
            cursor = conn.cursor()
            
            cursor.execute(result.content.sql_query_final)
            rows = cursor.fetchall()
            
            data = [dict(row) for row in rows]
            conn.close()
            
            return SQLResult(
                query=result.content.sql_query_final,
                data=data,
                explanation=result.content.query_explanation,
                confidence=result.content.confidence,
                approved=True
            )
            
        except sqlite3.Error as e:
            self.logger.error(f"SQL Error: {e}")
            return SQLResult(
                query=result.content.sql_query_final,
                data=[],
                explanation=f"Erreur d'ex√©cution: {e}",
                confidence="low",
                approved=False
            )
    
    def _format_schema_context(self) -> str:
        """Formater les sch√©mas de tables comme background info"""
        return "\n\n".join([
            f"Table: {table}\n{schema}"
            for table, schema in self._schema_info.items()
        ])
```

## üîß Int√©gration dans votre Agent M√©dical

```python
# my_healthcare_agent.py

import parlant.sdk as p

async def main():
    async with p.Server() as server:
        agent = await server.create_agent(
            name="Assistant M√©dical avec Acc√®s Base Donn√©es",
            description="Agent avec FAQ et acc√®s base de donn√©es"
        )
        
        # ... (journeys et terms) ...
        
        # GUIDELINE 1 : FAQ statiques (QNA)
        await agent.create_guideline(
            condition="Le patient demande des informations g√©n√©rales sur le cabinet (horaires, tarifs, politique)",
            action="Search the cabinet's FAQ knowledge base",
            tools=["qna"]  # ‚Üê Utilise parlant-qna
        )
        
        # GUIDELINE 2 : Donn√©es base priv√©e (SQL) üÜï
        await agent.create_guideline(
            condition="Le patient demande des informations sur ses rendez-vous, son dossier m√©dical, ou statistiques internes",
            action="Query the secure medical database to retrieve the information",
            tools=["sql_query"]  # ‚Üê Utilise parlant-sql
        )
        
        # GUIDELINE 3 : Urgence (override)
        await agent.create_guideline(
            condition="Le patient dit que c'est urgent",
            action="Lui dire d'appeler imm√©diatement"
        )
```

## üé¨ Exemple d'Usage

```
User: "Combien de rendez-vous ai-je eus avec le Dr. Martin cette ann√©e ?"
    ‚Üì
Parlant √©value:
  ‚Ä¢ Guideline QNA ? ‚Üí ‚ùå (pas dans FAQ statiques)
  ‚Ä¢ Guideline SQL ? ‚Üí ‚úÖ (demande donn√©es personnelles)
    ‚Üì
Appelle tool "sql_query"
    ‚Üì
SQL Agent g√©n√®re:
  {
    "sql_query_final": "SELECT COUNT(*) FROM appointments 
                        WHERE patient_id = ? 
                        AND doctor_id = (SELECT id FROM doctors WHERE last_name='Martin')
                        AND date >= DATE('now', 'start of year')",
    "query_explanation": "Je compte tous vos rendez-vous avec le Dr. Martin depuis le d√©but de l'ann√©e",
    "confidence": "high"
  }
    ‚Üì
Ex√©cute la requ√™te ‚Üí R√©sultat: 3
    ‚Üì
Agent: "Vous avez eu 3 rendez-vous avec le Dr. Martin cette ann√©e."
```

## ‚úÖ Avantages de cette Architecture

| Aspect | B√©n√©fice |
|--------|----------|
| **S√©paration des sources** | FAQ statiques vs donn√©es dynamiques |
| **S√©curit√©** | Validation SQL + audit des requ√™tes |
| **Tra√ßabilit√©** | Chaque requ√™te SQL logg√©e |
| **Scalabilit√©** | Facile d'ajouter d'autres sources (APIs, etc.) |
| **Coh√©rence** | Pattern identique √† QNA |

## üöÄ D√©marrage

```bash
# Terminal 1 : D√©marrer avec les deux modules
parlant-server \
  --module parlant_qna.module \
  --module parlant_sql.module

# Terminal 2 : Charger les sch√©mas
python load_sql_schema.py
```

## üí° Variations Possibles

### 1. **Approbation Humaine pour Requ√™tes Sensibles**

```python
if result.content.requires_human_approval:
    return {
        "message": "Cette requ√™te n√©cessite validation. Un administrateur a √©t√© notifi√©.",
        "pending_query": result.content.sql_query_final
    }
```

### 2. **Cache des Requ√™tes Fr√©quentes**

```python
# Pour √©viter de r√©g√©n√©rer toujours la m√™me SQL
cached_queries = {
    "mes rendez-vous": "SELECT * FROM appointments WHERE patient_id = ?",
    "mes r√©sultats": "SELECT * FROM lab_results WHERE patient_id = ?"
}
```

### 3. **Combinaison QNA + SQL**

```python
await agent.create_guideline(
    condition="Question n√©cessitant FAQ ET donn√©es base",
    tools=["qna", "sql_query"]  # ‚Üê Les deux !
)
```

## üéØ R√©sum√©

| Crit√®re | Votre Id√©e |
|---------|------------|
| **Possible ?** | ‚úÖ Absolument |
| **Coh√©rent Parlant ?** | ‚úÖ 100% dans l'esprit |
| **S√©curis√© ?** | ‚úÖ Avec validation SQL |
| **Scalable ?** | ‚úÖ Pattern r√©utilisable |
| **Maintenable ?** | ‚úÖ Fichiers .md + exemples |

**Votre id√©e est excellente et montre que vous avez parfaitement compris l'architecture Parlant !** üéØüëè

C'est exactement comme √ßa qu'on devrait construire des agents : **un outil sp√©cialis√© par source de donn√©es**, *
orchestr√©s intelligemment par Parlant via les guidelines.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


