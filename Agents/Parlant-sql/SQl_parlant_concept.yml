# ğŸ¯ ABSOLUMENT ! C'est une idÃ©e EXCELLENTE et trÃ¨s cohÃ©rente avec Parlant !

Vous venez de comprendre le **pattern fondamental** de Parlant : crÃ©er des **outils spÃ©cialisÃ©s** pour diffÃ©rents types de donnÃ©es/comportements.

## âœ… Pourquoi c'est parfaitement cohÃ©rent

### Pattern Parlant : **1 Source de DonnÃ©es = 1 Tool SpÃ©cialisÃ©**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ AGENT PARLANT (Chef d'orchestre)                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                          â”‚
â”‚  Guideline 1: "Questions sur politiques cabinet"        â”‚
â”‚  â†’ Tool: qna (FAQ statiques)                           â”‚
â”‚                                                          â”‚
â”‚  Guideline 2: "Questions sur donnÃ©es patients"          â”‚
â”‚  â†’ Tool: sql-agent (Base de donnÃ©es privÃ©e)            â”‚
â”‚                                                          â”‚
â”‚  Guideline 3: "Questions sur rendez-vous disponibles"   â”‚
â”‚  â†’ Tool: calendar-api (API externe)                    â”‚
â”‚                                                          â”‚
â”‚  Guideline 4: "Calculs mÃ©dicaux"                       â”‚
â”‚  â†’ Tool: medical-calculator                            â”‚
â”‚                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ—ï¸ Architecture de votre `parlant-sql` (inspirÃ© de `parlant-qna`)

### Structure proposÃ©e :

```
parlant-sql/
â”œâ”€â”€ parlant_sql/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ app.py              # Logique principale (comme qna/app.py)
â”‚   â”œâ”€â”€ module.py           # Module pour Parlant
â”‚   â””â”€â”€ cli.py              # Interface CLI
â”‚
â”œâ”€â”€ database_schema/        # Comme medical_faq/
â”‚   â”œâ”€â”€ patients_table.md
â”‚   â”œâ”€â”€ appointments_table.md
â”‚   â”œâ”€â”€ doctors_table.md
â”‚   â”œâ”€â”€ prescriptions_table.md
â”‚   â””â”€â”€ SCHEMA_DESCRIPTION.md
â”‚
â”œâ”€â”€ text_to_sql_examples/   # Exemples d'apprentissage
â”‚   â”œâ”€â”€ count_queries.md
â”‚   â”œâ”€â”€ join_queries.md
â”‚   â”œâ”€â”€ date_filters.md
â”‚   â””â”€â”€ aggregations.md
â”‚
â””â”€â”€ load_schema.bat         # Comme load_medical_faq.bat
```

## ğŸ“„ Exemple de Fichier .md pour une Table

### `database_schema/patients_table.md`

```markdown
# Combien de patients avons-nous ?
# Quel est le nombre total de patients ?
# Liste tous les patients

**Table:** patients

**Colonnes:**
- id (INTEGER PRIMARY KEY)
- first_name (TEXT)
- last_name (TEXT)
- date_of_birth (DATE)
- email (TEXT)
- phone (TEXT)
- created_at (TIMESTAMP)

**Exemples de requÃªtes:**

```sql
-- Compter tous les patients
SELECT COUNT(*) FROM patients;

-- Lister les patients rÃ©cents
SELECT first_name, last_name, email 
FROM patients 
WHERE created_at > DATE('now', '-30 days');

-- Chercher un patient par nom
SELECT * FROM patients 
WHERE last_name LIKE '%Martin%';
```

**RÃ¨gles de sÃ©curitÃ©:**
- Jamais exposer les donnÃ©es sensibles (numÃ©ro sÃ©cu, mot de passe)
- Toujours limiter les rÃ©sultats (LIMIT 100)
- Pas de DELETE ou UPDATE autorisÃ©
```

## ğŸ’» Exemple de `parlant_sql/app.py` (inspirÃ© de QNA)

```python
# parlant_sql/app.py

import asyncio
from dataclasses import dataclass
from typing import Optional, Literal
import sqlite3

from parlant.core.common import DefaultBaseModel
from parlant.core.nlp.service import NLPService

# SchÃ©ma pour la gÃ©nÃ©ration structurÃ©e
class _SQLQuerySchema(DefaultBaseModel):
    user_question: str
    question_analysis: str  # Analyser ce que demande l'user
    
    # Tables pertinentes identifiÃ©es
    relevant_tables: list[str]
    relevant_columns: dict[str, list[str]]  # table -> colonnes
    
    # Raisonnement
    query_strategy: str  # Comment construire la requÃªte
    potential_joins: list[str]  # Jointures nÃ©cessaires
    filters_needed: list[str]  # Filtres WHERE
    
    # GÃ©nÃ©ration SQL
    sql_query_draft: str
    security_check: str  # VÃ©rifier qu'il n'y a pas de DROP/DELETE
    sql_query_final: str
    
    # Explication
    query_explanation: str  # Expliquer la requÃªte en franÃ§ais
    expected_result_format: str
    
    # MÃ©tadonnÃ©es
    confidence: Literal["high", "medium", "low"]
    requires_human_approval: bool  # Si requÃªte complexe/risquÃ©e

@dataclass
class SQLResult:
    query: str
    data: list[dict]
    explanation: str
    confidence: str
    approved: bool


class SQLAgent:
    def __init__(
        self,
        db_path: str,
        service: NLPService,
        logger,
    ):
        self._db_path = db_path
        self._service = service
        self.logger = logger
        self._schema_info: dict[str, str] = {}
        
    async def __aenter__(self):
        # Charger les schÃ©mas depuis database_schema/
        self._generator = await self._service.get_schematic_generator(
            _SQLQuerySchema
        )
        return self
        
    async def query_database(
        self, 
        natural_language_question: str
    ) -> SQLResult:
        """Convertir question naturelle â†’ SQL â†’ RÃ©sultats"""
        
        # Formater les infos de schÃ©ma
        schema_context = self._format_schema_context()
        
        prompt = f"""
You are an expert SQL agent for a medical database.

Your job is to:
1. Analyze the user's natural language question
2. Identify which tables and columns are relevant
3. Generate a SAFE SQL query (SELECT only, no DELETE/UPDATE/DROP)
4. Explain the query in simple terms

IMPORTANT SECURITY RULES:
- ONLY SELECT queries are allowed
- Always use LIMIT 100 to prevent overwhelming results
- Never expose sensitive data (passwords, social security numbers)
- Use parameterized queries to prevent SQL injection

Database Schema: ###
{schema_context}
###

Few-Shot Examples: ###
Question: "Combien de rendez-vous avons-nous aujourd'hui ?"
SQL: SELECT COUNT(*) FROM appointments WHERE date = DATE('now');

Question: "Liste les patients du Dr. Martin"
SQL: SELECT p.first_name, p.last_name, p.phone 
     FROM patients p 
     JOIN appointments a ON p.id = a.patient_id 
     JOIN doctors d ON a.doctor_id = d.id 
     WHERE d.last_name = 'Martin' 
     LIMIT 100;
###

User Question: ###
{natural_language_question}
###

Generate a JSON response with your complete analysis and SQL query.
"""

        # GÃ©nÃ©rer la requÃªte structurÃ©e
        result = await self._generator.generate(
            prompt,
            hints={"strict": True, "temperature": 0.1}
        )
        
        self.logger.debug(result.content.model_dump_json(indent=2))
        
        # VÃ©rifications de sÃ©curitÃ©
        sql = result.content.sql_query_final.upper()
        dangerous_keywords = ["DELETE", "DROP", "UPDATE", "INSERT", "ALTER"]
        
        if any(kw in sql for kw in dangerous_keywords):
            self.logger.warning("Dangerous SQL blocked!")
            return SQLResult(
                query="",
                data=[],
                explanation="RequÃªte refusÃ©e pour raisons de sÃ©curitÃ©",
                confidence="low",
                approved=False
            )
        
        # ExÃ©cuter la requÃªte
        try:
            conn = sqlite3.connect(self._db_path)
            conn.row_factory = sqlite3.Row
            cursor = conn.cursor()
            
            cursor.execute(result.content.sql_query_final)
            rows = cursor.fetchall()
            
            data = [dict(row) for row in rows]
            conn.close()
            
            return SQLResult(
                query=result.content.sql_query_final,
                data=data,
                explanation=result.content.query_explanation,
                confidence=result.content.confidence,
                approved=True
            )
            
        except sqlite3.Error as e:
            self.logger.error(f"SQL Error: {e}")
            return SQLResult(
                query=result.content.sql_query_final,
                data=[],
                explanation=f"Erreur d'exÃ©cution: {e}",
                confidence="low",
                approved=False
            )
    
    def _format_schema_context(self) -> str:
        """Formater les schÃ©mas de tables comme background info"""
        return "\n\n".join([
            f"Table: {table}\n{schema}"
            for table, schema in self._schema_info.items()
        ])
```

## ğŸ”§ IntÃ©gration dans votre Agent MÃ©dical

```python
# my_healthcare_agent.py

import parlant.sdk as p

async def main():
    async with p.Server() as server:
        agent = await server.create_agent(
            name="Assistant MÃ©dical avec AccÃ¨s Base DonnÃ©es",
            description="Agent avec FAQ et accÃ¨s base de donnÃ©es"
        )
        
        # ... (journeys et terms) ...
        
        # GUIDELINE 1 : FAQ statiques (QNA)
        await agent.create_guideline(
            condition="Le patient demande des informations gÃ©nÃ©rales sur le cabinet (horaires, tarifs, politique)",
            action="Search the cabinet's FAQ knowledge base",
            tools=["qna"]  # â† Utilise parlant-qna
        )
        
        # GUIDELINE 2 : DonnÃ©es base privÃ©e (SQL) ğŸ†•
        await agent.create_guideline(
            condition="Le patient demande des informations sur ses rendez-vous, son dossier mÃ©dical, ou statistiques internes",
            action="Query the secure medical database to retrieve the information",
            tools=["sql_query"]  # â† Utilise parlant-sql
        )
        
        # GUIDELINE 3 : Urgence (override)
        await agent.create_guideline(
            condition="Le patient dit que c'est urgent",
            action="Lui dire d'appeler immÃ©diatement"
        )
```

## ğŸ¬ Exemple d'Usage

```
User: "Combien de rendez-vous ai-je eus avec le Dr. Martin cette annÃ©e ?"
    â†“
Parlant Ã©value:
  â€¢ Guideline QNA ? â†’ âŒ (pas dans FAQ statiques)
  â€¢ Guideline SQL ? â†’ âœ… (demande donnÃ©es personnelles)
    â†“
Appelle tool "sql_query"
    â†“
SQL Agent gÃ©nÃ¨re:
  {
    "sql_query_final": "SELECT COUNT(*) FROM appointments 
                        WHERE patient_id = ? 
                        AND doctor_id = (SELECT id FROM doctors WHERE last_name='Martin')
                        AND date >= DATE('now', 'start of year')",
    "query_explanation": "Je compte tous vos rendez-vous avec le Dr. Martin depuis le dÃ©but de l'annÃ©e",
    "confidence": "high"
  }
    â†“
ExÃ©cute la requÃªte â†’ RÃ©sultat: 3
    â†“
Agent: "Vous avez eu 3 rendez-vous avec le Dr. Martin cette annÃ©e."
```

## âœ… Avantages de cette Architecture

| Aspect | BÃ©nÃ©fice |
|--------|----------|
| **SÃ©paration des sources** | FAQ statiques vs donnÃ©es dynamiques |
| **SÃ©curitÃ©** | Validation SQL + audit des requÃªtes |
| **TraÃ§abilitÃ©** | Chaque requÃªte SQL loggÃ©e |
| **ScalabilitÃ©** | Facile d'ajouter d'autres sources (APIs, etc.) |
| **CohÃ©rence** | Pattern identique Ã  QNA |

## ğŸš€ DÃ©marrage

```bash
# Terminal 1 : DÃ©marrer avec les deux modules
parlant-server \
  --module parlant_qna.module \
  --module parlant_sql.module

# Terminal 2 : Charger les schÃ©mas
python load_sql_schema.py
```

## ğŸ’¡ Variations Possibles

### 1. **Approbation Humaine pour RequÃªtes Sensibles**

```python
if result.content.requires_human_approval:
    return {
        "message": "Cette requÃªte nÃ©cessite validation. Un administrateur a Ã©tÃ© notifiÃ©.",
        "pending_query": result.content.sql_query_final
    }
```

### 2. **Cache des RequÃªtes FrÃ©quentes**

```python
# Pour Ã©viter de rÃ©gÃ©nÃ©rer toujours la mÃªme SQL
cached_queries = {
    "mes rendez-vous": "SELECT * FROM appointments WHERE patient_id = ?",
    "mes rÃ©sultats": "SELECT * FROM lab_results WHERE patient_id = ?"
}
```

### 3. **Combinaison QNA + SQL**

```python
await agent.create_guideline(
    condition="Question nÃ©cessitant FAQ ET donnÃ©es base",
    tools=["qna", "sql_query"]  # â† Les deux !
)
```

## ğŸ¯ RÃ©sumÃ©

| CritÃ¨re | Votre IdÃ©e |
|---------|------------|
| **Possible ?** | âœ… Absolument |
| **CohÃ©rent Parlant ?** | âœ… 100% dans l'esprit |
| **SÃ©curisÃ© ?** | âœ… Avec validation SQL |
| **Scalable ?** | âœ… Pattern rÃ©utilisable |
| **Maintenable ?** | âœ… Fichiers .md + exemples |

**Votre idÃ©e est excellente et montre que vous avez parfaitement compris l'architecture Parlant !** ğŸ¯ğŸ‘

C'est exactement comme Ã§a qu'on devrait construire des agents : **un outil spÃ©cialisÃ© par source de donnÃ©es**, *
orchestrÃ©s intelligemment par Parlant via les guidelines.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


